package by.mksn.inintobot.currency

/**
 * Class which encapsulates alias matching logic with handling of 'wrong keyboard layout' issue.
 *
 * In case of alias collisions the original alias has a top priority over the 'switched' ones in
 * the same order as the source list.
 */
@ExperimentalStdlibApi
class CurrencyAliasMatcher(availableCurrencies: List<Currency>) {

    private val currencyAliases: Map<String, Currency> = sequence {
        // have to reverse as the `toMap` method takes last key collision over the first
        availableCurrencies.asReversed().forEach { currency ->
            currency.aliases.forEach { alias ->
                yield(alias.switchKeyboardEnglishToRussian().toLowerCase() to currency)
                yield(alias.switchKeyboardRussianToEnglish().toLowerCase() to currency)
                yield(alias.toUpperCase().switchKeyboardEnglishToRussian().toLowerCase() to currency)
                yield(alias.toUpperCase().switchKeyboardRussianToEnglish().toLowerCase() to currency)
            }
        }
        // the original name is a top priority
        availableCurrencies.asReversed().forEach { currency ->
            currency.aliases.forEach { alias -> yield(alias.toLowerCase() to currency) }
        }
        // the code is also an alias
        availableCurrencies.asReversed().forEach { yield(it.code.toLowerCase() to it) }
    }.toMap()

    /**
     * Autogenerated regular expression which matches all available aliases
     */
    val allAliasesRegex = currencyAliases.keys.asSequence()
        .map { alias -> Regex.escape(alias) }
        .distinct()
        .sortedByDescending { it.length }
        .joinToString("|", prefix = "(?iu)$BROAD_ALIAS_LOOKBEHIND(", postfix = ")(?-iu)")
        .toRegex()

    /**
     * Returns the corresponding [Currency] of the provided alias
     * @throws IllegalArgumentException in case of unknown alias
     */
    fun match(alias: String): Currency =
        currencyAliases[alias.toLowerCase()] ?: throw IllegalArgumentException("Invalid alias '$alias'")

    /**
     * Returns a string, contained of chars from the **russian** keyboard layout using the same *physical button* as a comparison criteria.
     * Buttons which do not contain any letter are remain the same (space, numbers, etc.)
     * Examples:
     * * "ghbdtn" -> "привет"
     * * "he,km" -> "рубль"
     * * "10 ,frcjd" -> "10 баксов"
     */
    private fun String.switchKeyboardEnglishToRussian() = mapChars {
        val idx = KEYBOARD_LETTERS_IN_ENGLISH.indexOf(it)
        if (idx == -1) it else KEYBOARD_LETTERS_IN_RUSSIAN[idx]
    }

    /**
     * Returns a string, contained of chars from the **english** keyboard layout using the same *physical button* as a comparison criteria.
     * Buttons which do not contain any letter are remain the same (space, numbers, etc.)
     * Examples:
     * * "вщддфкы" -> "dollars"
     * * "тшсу ещ ьууе нщг" -> "nice to meet you"
     * * "Хмфкшфиду_тфьуЪ" -> "{variable_name}"
     */
    private fun String.switchKeyboardRussianToEnglish() = mapChars {
        val idx = KEYBOARD_LETTERS_IN_RUSSIAN.indexOf(it)
        if (idx == -1) it else KEYBOARD_LETTERS_IN_ENGLISH[idx]
    }

    private inline fun String.mapChars(transform: (Char) -> Char): String {
        val chars = toCharArray()
        var index = 0
        for (char in chars)
            chars[index++] = transform(char)
        return String(chars)
    }

    companion object {
        // The 'native' typing mapping of russian symbols to the corresponding english symbols on the same keyboard buttons
        // (e.g. the person forgot to switch the keyboard to russian, but started typing and vice versa)
        // NOT ALL keyboard symbols included, just the buttons where at least one letter present (either russian or english)
        private const val KEYBOARD_LETTERS_IN_RUSSIAN =
            """йцукенгшщзхъфывапролджэячсмитьбюёЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮЁ"""
        private const val KEYBOARD_LETTERS_IN_ENGLISH =
            """qwertyuiop[]asdfghjkl;'zxcvbnm,.`QWERTYUIOP{}ASDFGHJKL:"ZXCVBNM<>~"""

        /**
         * Set of characters
         */
        private const val NON_LETTER_CHARS = "[];',.`{}:<>~"

        /**
         * Lookbehind regex statement which prevents capturing of two consequent aliases without spaces in-between them
         */
        private const val BROAD_ALIAS_LOOKBEHIND = "(?<![a-zA-Zа-яА-Я\\[\\];'\".,:<>~&&[^kKкКmMмМ]])"

        /**
         * Regex which represent the any character which can be used for the alias
         */
        private const val BROAD_ALIAS_CHAR = "[a-zA-Zа-яА-Я\\[\\];'\".,:<>~]"

        /**
         * Regex which represent the any charset which can be an alias for some currency.
         */
        val BROAD_ALIAS_REGEX = "$BROAD_ALIAS_LOOKBEHIND$BROAD_ALIAS_CHAR+".toRegex()
    }
}