package by.mksn.inintobot.misc


interface Aliasable {
    val aliases: Set<String>
}

/**
 * Class which encapsulates alias matching logic with handling of 'wrong keyboard layout' issue.
 *
 * In case of alias collisions the original alias has a top priority over the 'switched' ones in
 * the same order as the source list.
 */
class AliasMatcher<T : Aliasable>(available: List<T>) {

    private val aliases: Map<String, T> = sequence {
        // have to reverse as the `toMap` method takes last key collision over the first
        available.asReversed().forEach { aliasable ->
            aliasable.aliases.forEach { alias ->
                yield(alias.switchKeyboardEnglishToRussian().lowercase() to aliasable)
                yield(alias.switchKeyboardRussianToEnglish().lowercase() to aliasable)
                yield(alias.uppercase().switchKeyboardEnglishToRussian().lowercase() to aliasable)
                yield(alias.uppercase().switchKeyboardRussianToEnglish().lowercase() to aliasable)
            }
        }

        // the original name is a top priority
        available.asReversed().forEach { aliasable ->
            aliasable.aliases.forEach { alias -> yield(alias.lowercase() to aliasable) }
        }
    }.filterNot { it.first.length == 1 && it.first in KILO_MEGA_CHARS }.toMap()

    /**
     * Autogenerated escaped list of regular expression parts, each represent a single alias
     */
    val aliasRegexParts = aliases.keys.asSequence()
        .map { alias -> Regex.escape(alias) }
        .distinct()

    /**
     * Returns the corresponding object of the provided alias
     * @throws IllegalArgumentException in case of unknown alias
     */
    fun match(alias: String): T =
        aliases[alias.lowercase()] ?: throw IllegalArgumentException("Invalid alias '$alias'")

    /**
     * Returns the corresponding object of the provided alias or null if the [alias] do not represent any available currency
     */
    fun matchOrNull(alias: String): T? =
        aliases[alias.lowercase()]

    /**
     * Returns a string, contained of chars from the **russian** keyboard layout using the same *physical button* as a comparison criteria.
     * Buttons which do not contain any letter are remain the same (space, numbers, etc.)
     * Examples:
     * * "ghbdtn" -> "привет"
     * * "he,km" -> "рубль"
     * * "10 ,frcjd" -> "10 баксов"
     */
    private fun String.switchKeyboardEnglishToRussian() = mapChars {
        val idx = KEYBOARD_LETTERS_IN_ENGLISH.indexOf(it)
        if (idx == -1) it else KEYBOARD_LETTERS_IN_RUSSIAN[idx]
    }

    /**
     * Returns a string, contained of chars from the **english** keyboard layout using the same *physical button* as a comparison criteria.
     * Buttons which do not contain any letter are remain the same (space, numbers, etc.)
     * Examples:
     * * "вщддфкы" -> "dollars"
     * * "тшсу ещ ьууе нщг" -> "nice to meet you"
     * * "Хмфкшфиду_тфьуЪ" -> "{variable_name}"
     */
    private fun String.switchKeyboardRussianToEnglish() = mapChars {
        val idx = KEYBOARD_LETTERS_IN_RUSSIAN.indexOf(it)
        if (idx == -1) it else KEYBOARD_LETTERS_IN_ENGLISH[idx]
    }

    private inline fun String.mapChars(transform: (Char) -> Char): String {
        val chars = toCharArray()
        var index = 0
        for (char in chars)
            chars[index++] = transform(char)
        return String(chars)
    }

    companion object {
        // The 'native' typing mapping of russian symbols to the corresponding english symbols on the same keyboard buttons
        // (e.g. the person forgot to switch the keyboard to russian, but started typing and vice versa)
        // NOT ALL keyboard symbols included, just the buttons where at least one letter present (either russian or english)
        private const val KEYBOARD_LETTERS_IN_RUSSIAN =
            """йцукенгшщзхъфывапролджэячсмитьбюёЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮЁ"""
        private const val KEYBOARD_LETTERS_IN_ENGLISH =
            """qwertyuiop[]asdfghjkl;'zxcvbnm,.`QWERTYUIOP{}ASDFGHJKL:"ZXCVBNM<>~"""

        private const val KILO_MEGA_CHARS = "kKкКmMмМ"

        /**
         * Lookbehind regex statement which prevents capturing of two consequent aliases without spaces in-between them
         */
        private const val BROAD_ALIAS_LOOKBEHIND = "(?<![a-zA-Zа-яА-Я\\[\\];'\".,:<>~&&[^$KILO_MEGA_CHARS]])"

        /**
         * Create a complete regex from all available variables from the provided [aliasRegexParts] sequence
         */
        fun createAliasRegex(aliasRegexParts: Sequence<String>) = aliasRegexParts
            .sortedByDescending { it.length }
            .joinToString("|", prefix = "(?iu)$BROAD_ALIAS_LOOKBEHIND(", postfix = ")(?-iu)")
            .toRegex()
    }
}